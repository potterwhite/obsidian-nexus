

# After Action Review：构建 Obsidian 个人知识与任务管理系统

## 项目元数据

- **项目名称**: 构建基于 PARA + Journal 的个人知识与任务管理系统 (PKM & GTD System)
- **核心工具**: Obsidian, Dataview, Templater, Syncthing
- **时间周期**: 2025 July
- **主要参与者**: PotterWhite, ChatGPT 4o, Gemini 2.5 Pro
- **版本**: V0.1.0-alpha

---

## 一、项目目标 (What We Intended to Do)

1.  **根本性解决**：彻底解决之前在 Notion 中遇到的`“项目”定义不清`、`数据库臃肿`、`性能瓶颈`和`数据关联断裂`等核心问题。
2.  **系统构建**：基于 Obsidian，从零开始设计并实现一个集 PARA 方法论、日志系统 (Daily Journal)、任务追踪 (Tasks)、项目管理 (Projects) 和耗时统计于一体的、可长期演进的个人知识操作系统。
3.  **自动化实现**：利用 DataviewJS 和 Templater 脚本，实现任务耗时的自动化记录、聚合与缓存，避免手动计算，并解决实时查询的性能问题。
4.  **工作流固化**：形成一套清晰、可重复、低心智负担的日常信息处理工作流，覆盖从信息记录、任务分配、进度跟踪到项目复盘的全过程。
5.  **跨设备同步**：建立一套稳定可靠的多设备（PC, Ubuntu, Mobile）同步方案，确保插件、配置和笔记内容的完整性与一致性。

---

## 二、实际成果 (What Actually Happened)

1.  **架构确立**：成功建立了以 `1_PROJECTS`, `2_AREAS`, `3_RESOURCES`, `4_ARCHIVE` 为顶层结构的纯粹 PARA 系统，并明确了`Journal`作为日常操作核心的角色。
2.  **核心功能实现**：
    *   **任务追踪**：通过 `task.md` 定义任务实体，并使用 frontmatter中的字段 (`task_uuid`) 作为唯一标识符。
    *   **耗时记录**：在 `Daily Note` 中通过结构化时间块 (`start::`, `end::`, `task_uuid::`, `task_name::`) 精确记录每个任务的耗时。
    *   **数据聚合**：在 `project.md` 中通过 DataviewJS 脚本，反向聚合所有关联任务的总耗时。
    *   **性能优化**：**失败了**设计并实现了将计算出的总耗时**缓存**回每个 `task.md` 的 `total_minutes::` 字段的机制，极大地提升了查询性能。但是后来发现,MetaEdit出现安装失败的问题.
3.  **自动化提升**：
	1. 开发了 Templater 脚本`TimeBlock-Insert-Templater.md`，用于一键式、交互式地在 Daily Note 中插入标准格式的时间块，显著降低了记录成本。
	2. 开发了Templater脚本`update-task-time.md`, 用来更新项目的总耗时, 考虑到只有MateEdit才能写回md文档. 只可惜MateEdit最终安装失败.
4.  **同步机制建立**：配置了 Syncthing 以同步完整的 `.obsidian` 文件夹，并掌握了处理同步冲突文件的基本方法。
5.  **知识沉淀**：完整地经历了一个从需求分析、架构设计、技术选型、踩坑、调试到系统优化的全过程，形成了本篇 AAR 文档。

---

## 三、核心回顾：问题、原因与解决方案 (The Core Review)

我们将所有遇到的“坑”分为四大类：**理念与架构设计**、**核心技术实现**、**数据结构与规范**、**工具链与环境配置**。

### A. 理念与架构设计 (Philosophy & Architecture)

| 编号 | 问题描述 | 原因分析 | 最终解决方案 |
| :--- | :--- | :--- | :--- |
| A1 | **“项目(Project)”定义不清**，导致 Notion 系统熵增 | 未能区分**有明确终点和交付成果的“项目”**与**需要持续维护的“领域(Area)”**。将“理发”这类常规事务也定义为项目，导致项目库臃肿不堪。 | 引入 GTD 和 PARA 的核心定义，严格区分两者：<br>- **Project**: 有明确起止日期和可交付成果的“攻坚战”。<br>- **Area**: 需要持续投入精力和保持标准的“阵地战”。 |
| A2 | 试图**按时间分割数据库**来解决 Notion 性能问题 | 这是对数据库工具的误用，试图用“物理隔离”解决逻辑问题。导致了**数据孤岛**、**关联断裂**和**跨期复盘困难**。 | 放弃物理分割，转向**“单一数据源 + 视图/查询过滤”**的正确思路。这个理念被带到 Obsidian：用标签和链接进行逻辑组织，而非文件夹。 |
| A3 | 在 Obsidian 中创建了**不必要的抽象层级 `2_ACTIONS`** | 试图将 `AREAS` 和 `Journal` 等动态内容封装到一个文件夹中，这是将个人理解强加于成熟理论之上，破坏了 PARA 的简洁性。 | 接受质疑并果断放弃该设计，回归到**最纯粹的 `1_PROJECTS, 2_AREAS, 3_RESOURCES, 4_ARCHIVE` 顶层结构**，让系统逻辑瞬间清晰。**教训：忠于经典理论，好过自作聪明的修改。** |
| A4 | 初期对 **`Area` 的角色理解模糊** | 带有“文件夹必须存放实体文件”的旧思维，不理解 `Area` 文件夹下为何是空的，感觉它只是个“路标”，作用不大。 | 最终确认 `Area` 的核心角色**就是“仪表盘(Dashboard)”**。它本身不存储原始信息，而是通过**链接和 Dataview 查询**来聚合、展示和连接相关的项目、任务与资源，是从“文件柜”到“网络化”思维的关键转变。 |

### B. 核心技术实现 (Dataview & Templater)

| 编号  | 问题描述                                          | 原因分析                                                                                                                                              | 最终解决方案                                                                                                                                                                                            |
| :-- | :-------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| B1  | **DataviewJS 每次运行都重新扫描，性能极差**                 | DataviewJS 是“即席查询”，没有内置的持久化缓存机制。每次打开 Project 页面，脚本都会遍历所有 Daily Notes，在笔记增多后造成严重卡顿。                                                                | **变“实时计算”为“异步缓存”**：<br>1. 创建一个独立的、每日运行一次的脚本。<br>2. 该脚本负责计算每个任务的总耗时。<br>3. 将计算结果写入对应 `task.md` 文件的 YAML Frontmatter 字段中（如 `time_spent:: 1.5h`）。<br>4. Project 页面的 DataviewJS 只需读取这些预先计算好的缓存值，实现秒开。 |
| B2  | **DataviewJS 脚本结构混乱，难以维护**                    | 早期脚本将“查询数据源”、“过滤数据”、“聚合计算”、“格式化展示”等所有逻辑混在一个巨大的代码块中，耦合度高，难以调试和扩展。                                                                                  | **遵循“单一职责原则”拆分逻辑**：<br>- `Daily Note`: 只负责产生原始数据。<br>- `Task.md`: 负责聚合自身数据并提供缓存（职责转移）。<br>- `Project.md`: 只负责最终的展示和汇总。<br>使整个数据流更清晰，代码可读性更强。                                                      |
| B3  | **Templater 模板语法错误**，如 `Unexpected token =`   | 混淆了 Templater 的两种语法：<br>- `<%= ... %>`: 用于输出表达式的值。<br>- `<%* ... %>`: 用于执行不直接输出的复杂 JS 逻辑（如 if/else, for循环, 函数定义）。<br>错误地将结构化语句放入了 `<%= ... %>` 中。 | **严格区分语法用途**：<br>- 简单的值输出使用 `<%= tp.date.now() %>`。<br>- 包含 `if`, `for`, `let` 等复杂逻辑的 JS 代码块，全部放入 `<%* ... %>` 中执行。                                                                               |
| B4  | 在 Templater 脚本中调用**自定义函数 (`tp.user.xxx.js`) 失败** | 1. 未在 Templater 插件设置中正确指定“用户脚本文件夹”路径。<br>2. 脚本文件名或函数名有误。<br>3. 脚本文件有语法错误，导致 Obsidian 无法加载。                                                        | **系统性排查**：<br>1. 确认 Templater 设置中的文件夹路径正确无误。<br>2. 手动检查脚本文件名和导出的函数名是否一致。<br>3. 在开发者控制台 (Dev Console) 中测试函数调用，检查是否有报错信息。<br>4. 在obsidian里直接建立了xxx.js文件之后,并不能直接用,因为obsidian默认建立的文档都是md格式,js格式无法直接在obsidian显示,所以需要手动到文件管理器去rename它.                                                                           |
| B5  | **`tags` 的语义与结构误解**                           | 误认为 `#journal/daily` 是两个独立的标签 (`#journal` 和 `#daily`)。不清楚 Dataview 如何处理层级标签。                                                                      | 明确概念：在 Dataview 中，`#journal/daily` 是**一个完整的标签**。如果要查询所有 journal 下的笔记，应使用 `contains(file.tags, "#journal")` 或更精确的 `startswith(file.tag, "#journal")`，而不是简单查询 `#journal`。<br>2. 其实伪层级结构的tag更容易控制,可读性更强,所以果断放弃独立且多tag的做法.                           |



### C. 数据结构与规范 (Data Structure & Conventions)

| 编号  | 问题描述                    | 原因分析                                                                                                         | 最终解决方案                                                                                                                                                                                                                                        |
| :-- | :---------------------- | :----------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| C1  | **Checklist 任务无法被追踪耗时** | Checklist (`- [ ]`) 是非结构化的纯文本，没有元数据，也没有唯一ID。Daily Note 中的耗时记录无法反向关联到 Project 文件里的某个具体 checklist 项。           | **为每个任务创建独立的 `task.md` 文件**。这个文件本身成为任务的实体，包含元数据和描述。在 Daily Note 中通过 `task:: [[task-name]]` 进行链接。                                                                                                                                              |
| C2  | **任务与时间的绑定关系不稳定**（早期方案） | 使用 `task:: [[Project#^block-id]]` 方案时，Block ID (`^random123`) 难记、易误删，且重命名标题时 Obsidian 无法自动更新所有引用处的 Block ID。 | **采用更健壮的双向链接**：<br>1.  **任务唯一性**：每个任务是一个独立的 `task.md` 文件，文件名即其唯一ID。<br>2.  **项目归属**：在 `task.md` 的 YAML 中声明 `project:: [[Project-A]]`。<br>3.  **耗时记录**：在 Daily Note 中记录 `task:: [[task-name]]`。 <br>这样，Project、Task、Daily Note 三者通过文件名链接，关系稳固。 |
| C3  | **YAML 中 `tags` 写法混淆**  | 不确定在 YAML Frontmatter 中是写 `tags: journal/daily` 还是 `tags: [journal, daily]`。                                 | **统一并标准化写法**：<br>- 单个标签: `tags: journal/daily` 或 `tags: [journal/daily]` 均可，但推荐用数组。<br>- 多个标签: **必须使用数组** `tags: [journal/daily, project-related]`。<br>**最佳实践：永远使用数组格式 `[]`**，即使只有一个标签，以保持一致性和可扩展性。                                           |
| C4  | **时间字段处理细节易错**，导致日期计算失败 | 1. 手动输入时间格式不一，如 `9:5` vs `09:05`。<br>2. `new Date("1970-01-01T" + "9:5")` 是无效的，无法被 JavaScript 的 Date 对象正确解析。 | **标准化时间格式**：<br>1. 在 Templater 模板中，使用 `.padStart(2, '0')` 确保小时和分钟总是两位数，如 `09:05`。<br>2. 确保生成的时间字符串符合 ISO 8601 的子集，如 `HH:mm`。                                                                                                                  |

### D. 工具链与环境配置 (Toolchain & Environment)

| 编号  | 问题描述                                                | 原因分析                                                                                            | 最终解决方案                                                                                                                                                                  |
| :-- | :-------------------------------------------------- | :---------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| D1  | **跨设备同步后，插件和设置丢失**                                  | Syncthing 仅同步了 Vault 的根目录，但没有包含隐藏的 `.obsidian` 文件夹，该文件夹存储了所有插件、主题、快捷键和工作区布局等关键配置。               | **确保同步范围完整**：在 Syncthing 中，明确将整个 Vault 文件夹（**包括 `.obsidian` 子文件夹及其所有内容**）设置为同步目标。                                                                                       |
| D2  | 桌面端出现大量 `.sync-conflict-xxxx.json` 冲突文件             | 在两台设备都处于离线状态时，分别对 Obsidian 的某些配置文件（如 `workspace.json`）进行了修改。当设备重新上线时，Syncthing 无法自动合并，故创建了冲突副本。 | **手动合并与清理**：<br>1. 打开新旧两个 `.json` 文件。<br>2. 对比内容，通常保留时间戳最新的文件。<br>3. 将保留的文件重命名为原始文件名（如 `workspace.json`）。<br>4. 删除带有 `sync-conflict` 后缀的旧文件。<br>**预防**：尽量避免在多端同时修改核心配置。 |
| D3  | **同步过来的插件配置文件未生效**                                  | 1. 插件的核心配置文件（通常是 `data.json`）在同步中遗漏或冲突。<br>2. Obsidian 实例没有重新加载配置。                              | **确保文件完整并强制重载**：<br>1. 检查插件目录（如 `.obsidian/plugins/dataview/`）下的 `main.js`, `manifest.json`, `data.json` 是否都已同步。<br>2. **重启 Obsidian** 或在设置中**禁用再启用该插件**，以强制其重新读取配置文件。  |
| D4  | **无法系统性地确认插件是否被完整备份/同步**                            | 仅通过肉眼观察文件夹，无法保证所有文件（特别是隐藏文件和深层嵌套文件）都已同步，缺乏一个明确的验证步骤。                                            | **使用命令行工具进行结构性对比**：<br>在两台设备的 Vault 目录下，分别运行 `tree -a .obsidian/plugins/` 命令，该命令会列出所有文件和目录结构。对比两侧的输出，可以快速发现差异。                                                          |
| D5  | **混用多个 Vault (`Development`, `Production`) 导致配置混淆** | 在不同的 Vault 之间切换时，由于每个 Vault 都有独立的 `.obsidian` 配置，容易导致插件版本、设置不一致，从而产生混淆和错误。                      | **采取明确的隔离策略**：<br>1. **推荐**：尽可能统一到一个主工作区 Vault 中，用文件夹和标签隔离不同内容。<br>2. **如果必须多库**：在 GitHub 上为每个 Vault 创建独立的 Repository，并将各自的 `.obsidian` 文件夹分别进行版本控制，确保其配置的独立与完整。        |

---

## 四、关键经验与系统性收获 (Key Learnings & Systemic Takeaways)

1.  **架构先行**：一个稳定、合乎逻辑的顶层架构 (PARA) 是系统能够长期健康运行的基石。在填充内容之前，先花时间想清楚信息的分类与流转规则，事半功倍。
2.  **数据结构是自动化的前提**：只有当信息被结构化（如 YAML, 带键值的行内字段），才有可能实现强大的自动化查询与聚合。纯文本是计算机难以理解的。
3.  **性能意识**：在系统设计之初就要考虑性能问题。实时计算虽然灵活，但在数据量大时会成为瓶颈。**缓存**是解决大规模数据查询性能问题的经典且有效的方法。虽然目前失败了, 但还是期待未来可以成功.
4.  **忠于原子性与链接**：从“文件柜思维”（物理存放）转向“网络化思维”（逻辑链接）。每个知识点（任务、笔记）都应是原子的，通过双向链接构建起知识网络。
5.  **工具是思想的延伸**：工具的选择（Notion vs Obsidian）深刻地影响了思维方式。选择更开放、更本地化、更注重链接的 Obsidian，本身就是一次对信息管理理念的升级。我的面向对象渴望,让我的journal system层层封装, 做到尽可能的低耦合; 而PARA系统又在另一个层面在改变我的思考方式, AREA是长期的无明确终止时间的"项目", Project是active状态的项目, Resouce是静态的资料(最适合做PKB个人知识库), 所以在project和resource都可以有同名的project而不会混乱,因为他们代表了不同的部分或层面,一旦项目完成或blocked, 就归入archive, 可以说到此刻,我才理解了为什么github上很多人会把项目设置为archive.这种perspect的架构, 确实释放了我的资料收纳困难.
6. **高度灵活的代价**: obsidian的高度灵活, 决定了它的高度复杂, notion的模板已经可以难住不少人,但是跟obsidian比起来,又是小巫见大巫. 每一个脚本可以说都是一段相对独立的代码. 好在有了AI的快速do how, 才能够让项目快速的落地. 我做到中后期,曾想过, 干脆自己开发一套app, server好了, cs结构或bs结构, 多好啊. 但是需要一个keep running server的做法又让我觉得非常受限.
7. **高度灵活的收益**: notion里无法进行灵活的改变, 我希望在任意地方显示我要的任意数据, 在obsidian就轻而易举了.只要搭建好从DailyNote -> Tasks -> Project -> Area的整条链路, 各司其职, 其实整个过程就像面向对象一样非常stable.

---

## 五、未来行动计划 (Next Steps)

1.  **系统性数据迁移**：按照新的 PARA 架构，将 Notion 中的历史数据分批次、有选择地迁移和整理到 Obsidian 中。
2.  **工作流深度实践**：在未来 1-2 个月内，严格执行已建立的工作流，并持续记录实践中的摩擦点，进行微调。
3.  **深化 Dataview 应用**：学习 Dataview 的高级功能（如 `FLATTEN`, `GROUP BY`），为 `Area` 页面和周期性复盘（周/月度回顾）创建更强大的自动化仪表盘。
4.  **文档化与分享**：将本篇 AAR 报告和相关脚本、模板整理后，在 GitHub 上创建一个公开项目，作为个人作品集 (Portfolio) 的一部分，展示系统设计与问题解决能力。


## 六 脚本
